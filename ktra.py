# -*- coding: utf-8 -*-
"""KTRA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XBE4zS2lyUTFCOSpeK2Mbqad8D3QaE-
"""

import pandas as pd
import numpy as np
import datetime

df = pd.read_csv('/content/btcusd_1-min_data.csv')
df.head()

df['Datetime'] = pd.to_datetime(df['Timestamp'], unit='s')
df['Date'] = df['Datetime'].dt.date
df.head()

df.isnull().sum()

daily_close = df.groupby('Date')['Close'].last()
daily_close.head()

daily_return = np.log(daily_close / daily_close.shift(1)).dropna()
daily_return.head()

"""# **GARCH(p,q)**"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# === 1. CHIA DỮ LIỆU ===
train_size = int(0.8 * len(daily_return))
train_returns = daily_return[:train_size].values
test_returns = daily_return[train_size:].values

# === 2. HÀM LOG-LIKELIHOOD CHO GARCH(p, q) ===
def garch_log_likelihood(params, returns, p, q):
    omega = params[0]
    alpha = params[1:1+q]
    beta = params[1+q:]

    T = len(returns)
    max_lag = max(p, q)
    var = np.ones(T) * np.var(returns)

    for t in range(max_lag, T):
        var[t] = omega
        for i in range(1, q+1):
            var[t] += alpha[i-1] * returns[t-i]**2
        for j in range(1, p+1):
            var[t] += beta[j-1] * var[t-j]

    var[var <= 1e-10] = 1e-10
    ll = -0.5 * np.sum(np.log(2 * np.pi) + np.log(var) + (returns**2) / var)
    return -ll

# === 3. HÀM TÍNH VOLATILITY ===
def compute_garch_volatility(returns, omega, alpha, beta, init_var=None):
    p = len(beta)
    q = len(alpha)
    T = len(returns)
    max_lag = max(p, q)

    var = np.ones(T) * (np.var(returns) if init_var is None else init_var)

    for t in range(max_lag, T):
        var[t] = omega
        for i in range(1, q+1):
            var[t] += alpha[i-1] * returns[t-i]**2
        for j in range(1, p+1):
            var[t] += beta[j-1] * var[t-j]

    return np.sqrt(var)

# === 4. HÀM ĐÁNH GIÁ TRÊN TEST ===
def evaluate_garch_loglik(returns, omega, alpha, beta, init_var=None):
    vol = compute_garch_volatility(returns, omega, alpha, beta, init_var)
    var = vol**2
    var[var <= 1e-10] = 1e-10
    ll = -0.5 * np.sum(np.log(2 * np.pi) + np.log(var) + (returns**2) / var)
    return ll

# === 5. THAY ĐỔI P, Q Ở ĐÂY ===
p, q = 1, 2

# Khởi tạo tham số
initial_params = [1e-6] + [0.05]*q + [0.9]*p
bounds = [(1e-10, 1)] * (1 + q + p)

# Ràng buộc: alpha + beta < 1
def constraint_sum(params):
    alpha = params[1:1+q]
    beta = params[1+q:]
    return 1 - np.sum(alpha) - np.sum(beta)

constraints = {'type': 'ineq', 'fun': constraint_sum}

# === 6. TỐI ƯU HÓA ===
result = minimize(garch_log_likelihood, initial_params, args=(train_returns, p, q),
                  bounds=bounds, constraints=constraints)

params_opt = result.x
omega = params_opt[0]
alpha = params_opt[1:1+q]
beta = params_opt[1+q:]

print(f"[GARCH({p},{q}) PARAMS]")
print(f"omega = {omega:.6f}")
print(f"alpha = {alpha}")
print(f"beta  = {beta}")

# === 7. TÍNH VOLATILITY TRAIN / TEST ===
vol_train = compute_garch_volatility(train_returns, omega, alpha, beta)
init_test_var = vol_train[-1]**2
vol_test = compute_garch_volatility(test_returns, omega, alpha, beta, init_var=init_test_var)

# === 8. ĐÁNH GIÁ ===
loglik_test = evaluate_garch_loglik(test_returns, omega, alpha, beta, init_var=init_test_var)
mse_test = np.mean((test_returns**2 - vol_test**2)**2)

print(f"\nTest Log-Likelihood: {loglik_test:.2f}")
print(f"Test MSE (r² - σ²): {mse_test:.6f}")

# === 9. VẼ BIỂU ĐỒ ===
plt.figure(figsize=(14, 5))
plt.plot(np.arange(len(vol_train)), vol_train, label=f'Train Volatility (GARCH({p},{q}))', color='blue')
plt.plot(np.arange(len(vol_train), len(vol_train) + len(vol_test)), vol_test, label='Test Volatility', color='orange')
plt.axvline(x=len(vol_train), linestyle='--', color='black', label='Train/Test Split')
plt.title(f'Volatility GARCH({p},{q}) - Train vs Test')
plt.xlabel('Time Index')
plt.ylabel('Volatility')
plt.legend()
plt.tight_layout()
plt.show()

"""# **ARCH(p)**"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# === 1. CHIA TẬP TRAIN / TEST ===
train_size = int(0.8 * len(daily_return))
train_returns = daily_return[:train_size].values
test_returns = daily_return[train_size:].values

# === 2. HÀM LOG-LIKELIHOOD CHO ARCH(p) ===
def arch_p_log_likelihood(params, returns, p):
    omega = params[0]
    alphas = params[1:]
    T = len(returns)
    var = np.zeros(T)
    var[:p] = np.var(returns)

    for t in range(p, T):
        var[t] = omega + sum(alphas[i] * returns[t - i - 1]**2 for i in range(p))

    var[var <= 1e-10] = 1e-10
    ll = -0.5 * np.sum(np.log(2 * np.pi) + np.log(var[p:]) + (returns[p:]**2) / var[p:])
    return -ll

# === 3. THIẾT LẬP ARCH(p) ===
p = 2
initial_params = [1e-6] + [0.05] * p
bounds = [(1e-10, 1)] * (p + 1)

# === 4. TỐI ƯU HÓA ===
result = minimize(arch_p_log_likelihood, initial_params, args=(train_returns, p), bounds=bounds)
omega_arch = result.x[0]
alphas_arch = result.x[1:]

print(f"[ARCH({p}) PARAMS]")
print(f"omega = {omega_arch:.6f}")
for i, a in enumerate(alphas_arch, 1):
    print(f"alpha_{i} = {a:.4f}")

# === 5. TÍNH VOLATILITY ===
def compute_arch_p_volatility(returns, omega, alphas, p, init_var=None):
    T = len(returns)
    var = np.zeros(T)
    var[:p] = np.var(returns) if init_var is None else init_var

    for t in range(p, T):
        var[t] = omega + sum(alphas[i] * returns[t - i - 1]**2 for i in range(p))
    return np.sqrt(var)

vol_train = compute_arch_p_volatility(train_returns, omega_arch, alphas_arch, p)
init_test_var = vol_train[-p:]**2
vol_test = compute_arch_p_volatility(test_returns, omega_arch, alphas_arch, p, init_var=init_test_var)

# === 6. ĐÁNH GIÁ TRÊN TẬP TEST ===
def evaluate_log_likelihood_arch_p(returns, omega, alphas, p, init_var=None):
    T = len(returns)
    var = np.zeros(T)
    var[:p] = np.var(returns) if init_var is None else init_var

    for t in range(p, T):
        var[t] = omega + sum(alphas[i] * returns[t - i - 1]**2 for i in range(p))
    var[var <= 1e-10] = 1e-10

    ll = -0.5 * np.sum(np.log(2 * np.pi) + np.log(var[p:]) + (returns[p:]**2) / var[p:])
    return ll

loglik_test = evaluate_log_likelihood_arch_p(test_returns, omega_arch, alphas_arch, p, init_var=init_test_var)
mse_test = np.mean((test_returns[p:]**2 - vol_test[p:]**2)**2)

print(f"\nTest Log-Likelihood: {loglik_test:.2f}")
print(f"Test MSE (r² - σ²): {mse_test:.6f}")

# === 7. VẼ BIỂU ĐỒ ===
plt.figure(figsize=(14, 5))
plt.plot(np.arange(len(vol_train)), vol_train, label=f'Train Volatility (ARCH({p}))', color='blue')
plt.plot(np.arange(len(vol_train), len(vol_train) + len(vol_test)), vol_test, label='Test Volatility', color='orange')
plt.axvline(x=len(vol_train), linestyle='--', color='black', label='Train/Test Split')
plt.title(f'Volatility ARCH({p}) - Train vs Test')
plt.xlabel('Time Index')
plt.ylabel('Volatility')
plt.legend()
plt.tight_layout()
plt.show()